#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <memory>
#include <functional>
#include <mutex>
#include "../local_models/LocalModelBase.h"

namespace iOS {
namespace AIFeatures {
namespace VulnerabilityDetection {

/**
 * @class VulnerabilityDetector
 * @brief Class for detecting vulnerabilities in Roblox games
 * 
 * This class uses locally trained models to scan Roblox games for vulnerabilities,
 * backdoors, or potential exploit targets. It learns from game interactions and
 * evolves its detection capabilities over time.
 */
class VulnerabilityDetector {
public:
    // Vulnerability type enumeration
    enum class VulnerabilityType {
        RemoteEvent,       // Vulnerable remote events
        RemoteFunction,    // Vulnerable remote functions
        SecurityBypass,    // Security bypass opportunities
        FilterBypass,      // Filter bypasses
        ServerStorage,     // Accessible server storage
        BackdoorScript,    // Backdoor scripts
        NetworkOwnership,  // Network ownership vulnerabilities
        GameSpecific,      // Game-specific vulnerabilities
        Unknown            // Unknown vulnerability type
    };
    
    // Vulnerability structure
    struct Vulnerability {
        std::string m_id;                  // Unique identifier
        std::string m_name;                // Vulnerability name
        std::string m_description;         // Vulnerability description
        VulnerabilityType m_type;          // Vulnerability type
        std::string m_path;                // Path in game hierarchy
        std::string m_exploitCode;         // Code to exploit vulnerability
        float m_severity;                  // Severity (0-1)
        float m_reliability;               // Reliability (0-1)
        uint64_t m_discoveryTime;          // When it was discovered
        bool m_verified;                   // Whether it's been verified
        std::vector<std::string> m_tags;   // Tags for categorization
        std::unordered_map<std::string, std::string> m_metadata; // Additional metadata
        
        Vulnerability()
            : m_type(VulnerabilityType::Unknown), m_severity(0.5f), m_reliability(0.5f),
              m_discoveryTime(0), m_verified(false) {}
    };
    
    // Game scan result structure
    struct ScanResult {
        std::string m_gameId;              // Game identifier
        std::string m_gameName;            // Game name
        std::vector<Vulnerability> m_vulnerabilities; // Discovered vulnerabilities
        uint64_t m_scanTime;               // When scan was performed
        uint64_t m_scanDuration;           // Scan duration in milliseconds
        bool m_scanComplete;               // Whether scan completed
        std::string m_errorMessage;        // Error message if scan failed
        
        ScanResult()
            : m_scanTime(0), m_scanDuration(0), m_scanComplete(false) {}
    };
    
    // Scan progress structure
    struct ScanProgress {
        float m_progress;                  // Progress (0-1)
        std::string m_currentActivity;     // Current scan activity
        uint32_t m_vulnerabilitiesFound;   // Number of vulnerabilities found so far
        bool m_isActive;                   // Whether scan is active
        
        ScanProgress()
            : m_progress(0.0f), m_vulnerabilitiesFound(0), m_isActive(false) {}
    };
    
    // Game object structure
    struct GameObject {
        std::string m_name;                // Object name
        std::string m_className;           // Object class name
        std::string m_path;                // Full path in hierarchy
        std::unordered_map<std::string, std::string> m_properties; // Object properties
        std::vector<std::shared_ptr<GameObject>> m_children; // Child objects
        
        GameObject() {}
        
        GameObject(const std::string& name, const std::string& className)
            : m_name(name), m_className(className) {}
    };
    
    // Callback types
    using ScanProgressCallback = std::function<void(const ScanProgress&)>;
    using ScanCompleteCallback = std::function<void(const ScanResult&)>;
    using VulnerabilityDetectedCallback = std::function<void(const Vulnerability&)>;
    
private:
    // Models
    std::shared_ptr<LocalModels::LocalModelBase> m_remoteEventModel;
    std::shared_ptr<LocalModels::LocalModelBase> m_scriptAnalysisModel;
    std::shared_ptr<LocalModels::LocalModelBase> m_networkAnalysisModel;
    
    // Detection state
    std::string m_currentGameId;
    std::string m_currentGameName;
    std::shared_ptr<GameObject> m_gameRoot;
    std::unordered_map<std::string, ScanResult> m_scanHistory;
    std::vector<Vulnerability> m_knownVulnerabilities;
    ScanProgress m_currentScanProgress;
    bool m_isScanning;
    bool m_isInitialized;
    
    // Callbacks
    ScanProgressCallback m_progressCallback;
    ScanCompleteCallback m_completeCallback;
    VulnerabilityDetectedCallback m_detectedCallback;
    
    // Thread safety
    mutable std::mutex m_mutex;
    
    // Private methods
    bool InitializeModels();
    void ScanGameObject(const std::shared_ptr<GameObject>& gameObject, ScanResult& result);
    bool AnalyzeRemoteEvent(const std::shared_ptr<GameObject>& remoteEvent, ScanResult& result);
    bool AnalyzeRemoteFunction(const std::shared_ptr<GameObject>& remoteFunction, ScanResult& result);
    bool AnalyzeScript(const std::shared_ptr<GameObject>& script, const std::string& code, ScanResult& result);
    bool CheckFilterBypass(const std::string& code, ScanResult& result);
    bool CheckForBackdoors(const std::string& code, ScanResult& result);
    bool CheckNetworkOwnership(const std::shared_ptr<GameObject>& part, ScanResult& result);
    std::vector<std::string> ExtractPotentialExploits(const std::string& code);
    std::string GenerateExploitCode(const Vulnerability& vulnerability);
    void UpdateScanProgress(float progress, const std::string& activity, uint32_t vulnerabilitiesFound);
    void AddVulnerability(ScanResult& result, const Vulnerability& vulnerability);
    std::string GenerateVulnerabilityId();
    bool IsKnownVulnerability(const Vulnerability& vulnerability);
    std::vector<std::string> GenerateVulnerabilityTags(const Vulnerability& vulnerability);
    float CalculateVulnerabilitySeverity(const Vulnerability& vulnerability);
    float CalculateVulnerabilityReliability(const Vulnerability& vulnerability);
    void SaveVulnerabilityDatabase();
    bool LoadVulnerabilityDatabase();
    bool TrainModelsWithDetectionHistory();
    
public:
    /**
     * @brief Constructor
     */
    VulnerabilityDetector();
    
    /**
     * @brief Destructor
     */
    ~VulnerabilityDetector();
    
    /**
     * @brief Initialize the vulnerability detector
     * @param modelPath Path to store model data
     * @return True if initialization succeeded
     */
    bool Initialize(const std::string& modelPath);
    
    /**
     * @brief Start scanning a game
     * @param gameId Game identifier
     * @param gameName Game name
     * @param gameRoot Root game object
     * @param progressCallback Callback for scan progress
     * @param completeCallback Callback for scan completion
     * @return True if scan started successfully
     */
    bool StartScan(const std::string& gameId,
                  const std::string& gameName,
                  std::shared_ptr<GameObject> gameRoot,
                  ScanProgressCallback progressCallback = nullptr,
                  ScanCompleteCallback completeCallback = nullptr);
    
    /**
     * @brief Cancel the current scan
     * @return True if scan was cancelled
     */
    bool CancelScan();
    
    /**
     * @brief Get the current scan progress
     * @return Scan progress
     */
    ScanProgress GetScanProgress();
    
    /**
     * @brief Check if a scan is in progress
     * @return True if scanning
     */
    bool IsScanning() const;
    
    /**
     * @brief Get scan history
     * @return Map of game IDs to scan results
     */
    std::unordered_map<std::string, ScanResult> GetScanHistory() const;
    
    /**
     * @brief Get a specific scan result
     * @param gameId Game identifier
     * @return Scan result or empty result if not found
     */
    ScanResult GetScanResult(const std::string& gameId) const;
    
    /**
     * @brief Get all known vulnerabilities
     * @return Vector of vulnerabilities
     */
    std::vector<Vulnerability> GetKnownVulnerabilities() const;
    
    /**
     * @brief Get vulnerabilities by type
     * @param type Vulnerability type
     * @return Vector of vulnerabilities of the specified type
     */
    std::vector<Vulnerability> GetVulnerabilitiesByType(VulnerabilityType type) const;
    
    /**
     * @brief Get vulnerabilities by game
     * @param gameId Game identifier
     * @return Vector of vulnerabilities in the specified game
     */
    std::vector<Vulnerability> GetVulnerabilitiesByGame(const std::string& gameId) const;
    
    /**
     * @brief Set vulnerability detected callback
     * @param callback Callback function
     */
    void SetVulnerabilityDetectedCallback(VulnerabilityDetectedCallback callback);
    
    /**
     * @brief Add a manually discovered vulnerability
     * @param vulnerability Vulnerability to add
     * @return True if vulnerability was added
     */
    bool AddVulnerability(const Vulnerability& vulnerability);
    
    /**
     * @brief Report vulnerability exploit attempt
     * @param vulnerabilityId Vulnerability identifier
     * @param success Whether the exploit was successful
     * @param feedback Additional feedback
     * @return True if report was recorded
     */
    bool ReportExploitAttempt(const std::string& vulnerabilityId, 
                            bool success,
                            const std::string& feedback = "");
    
    /**
     * @brief Check game for server-side execution vulnerabilities
     * @param gameId Game identifier
     * @return Vector of potential server-side execution vulnerabilities
     */
    std::vector<Vulnerability> CheckForServerSideExecution(const std::string& gameId);
    
    /**
     * @brief Analyze network traffic for vulnerabilities
     * @param gameId Game identifier
     * @param packetData Raw packet data
     * @return Vector of discovered vulnerabilities
     */
    std::vector<Vulnerability> AnalyzeNetworkTraffic(const std::string& gameId,
                                                   const std::vector<uint8_t>& packetData);
    
    /**
     * @brief Train the detection models
     * @return True if training succeeded
     */
    bool TrainModels();
    
    /**
     * @brief Convert vulnerability type to string
     * @param type Vulnerability type
     * @return String representation
     */
    static std::string VulnerabilityTypeToString(VulnerabilityType type);
    
    /**
     * @brief Convert string to vulnerability type
     * @param str String representation
     * @return Vulnerability type
     */
    static VulnerabilityType StringToVulnerabilityType(const std::string& str);
};

} // namespace VulnerabilityDetection
} // namespace AIFeatures
} // namespace iOS
